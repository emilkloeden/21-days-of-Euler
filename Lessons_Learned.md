# Problem 1: Multiples of 3 and 5
## Problem Description:
If we list all the natural numbers below 10 that are multiples of 3 or 5, we get 3, 5, 6 and 9. The sum of these multiples is 23. Find the sum of all the multiples of 3 or 5 below 1000.
 
## Breaking it down:
1. Get a list of all numbers between 1 and 999 inclusive
2. Create a new list from the first returning only those divisable by 3 or 5 (possibly more than one step required)
3. Sum the resultant list
 
## Ruby-specific
1. Using a splat ```(1..999)``` we can easily create an array with all numbers from 1 to 999 inclusive.
2. Many methods take code blocks as parameters. 
3. Multi-line code blocks are enclosed  ```do``` and ```end```. Single-line code blocks use ```{``` and ```}```. 
4. Variables within code blocks are wrapped in pipes and can be comma-delimited e.g. ```|name, school|```
5. The Enumerable module uses 'mix-ins' which the Array class sort-of inherits.
6. One mix-in, the Enumerable#find_all method takes an array and a code block and returns a filtered array of only the elements to which the code block returns true e.g. ```[1,2,3].findall { |a| a.even? }``` returns ```=>[2]```
7. Another method ```inject``` takes an optional starting value e.g. ```(0)``` and a code block and folds the array e.g ```[1,2,3].inject(0) { |totalToDate, currentIndex| totalToDate + currentIndex }``` is the idiomatic way to sum an array in Ruby *which seems pretty unnecessarily complex for what otherwise seems like a very programmer-friendly language*
8. Method chaining exists using ```.```. Hooray.
9. The ruby print method is called ```puts```. A minor nuisance.
 
## C++-specific
1. I kind of lucked out and this solution was pretty easy having developed the algorithm previously. Conversely I didn't learn much on this exercise.
2. There is an C++ interpreter on tutorialspoint.com to save compilation (although once I download gcc I'd like to get more comfortable with it).
3. Arrays in C are immutable (the length cannot change). As such I realised an even simpler solution, instead of summing the contents of an array, I declared a variable of value 0 and added to it each iteration where the divisible by 3 or 5 condition returned true.
4. C syntax is refreshingly similar to javascript. This is nice.
 
 
# Problem 2
## Problem Description:
Each new term in the Fibonacci sequence is generated by adding the previous two terms. By starting with 1 and 2, the first 10 terms will be:
1, 2, 3, 5, 8, 13, 21, 34, 55, 89, ...
By considering the terms in the Fibonacci sequence whose values do not exceed four million, find the sum of the even-valued terms.
 
## Breaking it down:
1. Define a function to return a fibonacci number
2. Populate an array with even fibonacci numbers. Stop populating when the fibonacci number exceeds 4 million.
3. Sum that array.
 
## Ruby Specific:
1. The ```puts``` method has an alias ```p```. This is good because one can pretend it means ```print```. Also less keystrokes.
2. Comparative variable assignment which also exists in python (but not javascript) is awesome and means you can do this
    a, b = 0, 1
    a, b = b, a + b
instead of:
    a = 0
    b = 1
    c = b
    a = c
    b = a + c
    
3. The ```until``` statement runs a anteceding code statement until it returns true
4. The ```until``` modifier runs a preceding code statement until it returns false
5. The ```until``` statement is functionally equivalent to the ```while``` modified and the ```until``` modifier is functionally equivalent to the ```while``` statement.
6. Points 3->5 enable you to write code logically, whatever way your brain is thinking at the time. This can be seen in my posted solution where I used the until statement in the method definition and the until modifier later on. Surely projects involving one or more people would set usage standards. ```if``` has a modifier and it's counterpart is ```unless```.
7. Ruby has a for a in expression syntax much like python's for loops. I didn't get to use this but I would like to remember it for the next Ruby solution. It is functionally equivalent to Array.each { |a| a.expression }